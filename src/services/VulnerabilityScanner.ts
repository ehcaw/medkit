import { 
  ScanRequest, 
  ScanResult, 
  ScanOptions, 
  VulnerabilityFinding,
  ScanSummary,
  ScanMetadata,
  LLMPrompt,
  DocumentationSuggestion
} from '../models/index.js';
import { CodeParser, ParsedFile } from './CodeParser.js';
import { StaticAnalyzer } from '../analyzers/StaticAnalyzer.js';
import { PromptGenerator } from './PromptGenerator.js';
import { DataValidator } from '../utils/validation.js';
import { 
  XSSRule, 
  SQLInjectionRule, 
  CommandInjectionRule, 
  HardcodedSecretsRule, 
  InsecureRandomRule, 
  NoCSRFRule 
} from '../analyzers/rules/SecurityRules.js';
import {
  ReactRerenderRule,
  LargeBundleRule,
  MemoryLeakRule,
  ExpensiveOperationRule,
  MissingMemoizationRule,
  InefficientCSSRule
} from '../analyzers/rules/PerformanceRules.js';

export class VulnerabilityScanner {
  private parser: CodeParser;
  private analyzer: StaticAnalyzer;
  private promptGenerator: PromptGenerator;

  constructor() {
    this.parser = new CodeParser();
    this.analyzer = new StaticAnalyzer();
    this.promptGenerator = new PromptGenerator();
    
    this.initializeRules();
  }

  private initializeRules(): void {
    // Add security rules
    this.analyzer.addRule(new XSSRule());
    this.analyzer.addRule(new SQLInjectionRule());
    this.analyzer.addRule(new CommandInjectionRule());
    this.analyzer.addRule(new HardcodedSecretsRule());
    this.analyzer.addRule(new InsecureRandomRule());
    this.analyzer.addRule(new NoCSRFRule());

    // Add performance rules
    this.analyzer.addRule(new ReactRerenderRule());
    this.analyzer.addRule(new LargeBundleRule());
    this.analyzer.addRule(new MemoryLeakRule());
    this.analyzer.addRule(new ExpensiveOperationRule());
    this.analyzer.addRule(new MissingMemoizationRule());
    this.analyzer.addRule(new InefficientCSSRule());
  }

  async scanCode(request: ScanRequest): Promise<ScanResult> {
    const startTime = Date.now();
    
    try {
      // Validate request
      DataValidator.validateScanRequest(request);

      // Parse the code
      const parsedFile = await this.parseInput(request);
      
      // Analyze for vulnerabilities
      const findings = await this.analyzeCode(parsedFile, request.options);
      
      // Generate prompts if requested
      let prompts: LLMPrompt[] = [];
      if (request.options.generatePrompts) {
        prompts = this.promptGenerator.generatePrompts(
          findings, 
          request.options.llmModel || 'generic'
        );
      }

      // Generate documentation suggestions if requested
      let documentation: DocumentationSuggestion[] = [];
      if (request.options.generateDocumentation) {
        documentation = this.generateDocumentationSuggestions(findings, parsedFile);
      }

      // Calculate summary and metadata
      const summary = this.calculateSummary(findings, parsedFile, Date.now() - startTime);
      const metadata = this.calculateMetadata(parsedFile);

      return {
        id: this.generateScanId(),
        requestId: request.id,
        status: 'completed',
        findings,
        summary,
        metadata,
        prompts,
        documentation,
        createdAt: new Date(),
        completedAt: new Date()
      };

    } catch (error) {
      return {
        id: this.generateScanId(),
        requestId: request.id,
        status: 'failed',
        findings: [],
        summary: {
          totalFindings: 0,
          securityFindings: 0,
          performanceFindings: 0,
          criticalCount: 0,
          highCount: 0,
          mediumCount: 0,
          lowCount: 0,
          filesScanned: 0,
          linesOfCode: 0,
          scanDuration: Date.now() - startTime
        },
        metadata: {
          files: [],
          languages: [],
          frameworks: [],
          dependencies: [],
          totalSize: 0
        },
        createdAt: new Date(),
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  async scanFile(filePath: string, options: ScanOptions): Promise<ScanResult> {
    const request: ScanRequest = {
      id: this.generateRequestId(),
      source: 'file',
      input: filePath,
      options,
      createdAt: new Date()
    };

    return this.scanCode(request);
  }

  async scanURL(url: string, options: ScanOptions): Promise<ScanResult> {
    const request: ScanRequest = {
      id: this.generateRequestId(),
      source: 'url',
      input: url,
      options,
      createdAt: new Date()
    };

    return this.scanCode(request);
  }

  async scanCodeString(code: string, language: string, options: ScanOptions): Promise<ScanResult> {
    const request: ScanRequest = {
      id: this.generateRequestId(),
      source: 'code',
      input: code,
      options,
      createdAt: new Date()
    };

    return this.scanCode(request);
  }

  private async parseInput(request: ScanRequest): Promise<ParsedFile> {
    switch (request.source) {
      case 'file':
        return await this.parser.parseFile(request.input, request.options.maxFileSize);
      
      case 'url':
        // TODO: Implement URL crawling
        throw new Error('URL scanning not yet implemented');
      
      case 'code':
        return await this.parser.parseCode(request.input, 'javascript');
      
      default:
        throw new Error(`Unsupported source type: ${request.source}`);
    }
  }

  private async analyzeCode(parsedFile: ParsedFile, options: ScanOptions): Promise<VulnerabilityFinding[]> {
    const findings: VulnerabilityFinding[] = [];

    // Configure analyzer based on options
    if (!options.includeSecurity) {
      this.disableSecurityRules();
    }
    if (!options.includePerformance) {
      this.disablePerformanceRules();
    }

    // Run analysis
    const analysisResult = await this.analyzer.analyzeFiles([parsedFile]);
    findings.push(...analysisResult.findings);

    // Apply custom rules if provided
    if (options.customRules && options.customRules.length > 0) {
      const customFindings = await this.applyCustomRules(parsedFile, options.customRules);
      findings.push(...customFindings);
    }

    return findings;
  }

  private disableSecurityRules(): void {
    const securityRuleIds = ['SEC001', 'SEC002', 'SEC003', 'SEC004', 'SEC005', 'SEC006'];
    securityRuleIds.forEach(id => this.analyzer.disableRule(id));
  }

  private disablePerformanceRules(): void {
    const performanceRuleIds = ['PERF001', 'PERF002', 'PERF003', 'PERF004', 'PERF005', 'PERF006'];
    performanceRuleIds.forEach(id => this.analyzer.disableRule(id));
  }

  private async applyCustomRules(parsedFile: ParsedFile, customRules: string[]): Promise<VulnerabilityFinding[]> {
    // TODO: Implement custom rule application
    // This would parse and apply user-defined rules
    return [];
  }

  private generateDocumentationSuggestions(findings: VulnerabilityFinding[], parsedFile: ParsedFile): DocumentationSuggestion[] {
    const suggestions: DocumentationSuggestion[] = [];

    // Generate suggestions for undocumented components
    const componentRegex = /(?:function|const)\s+(\w+)\s*=\s*(?:React\.)?(?:memo\s*\()?\(/g;
    let match;
    const content = parsedFile.content;
    
    while ((match = componentRegex.exec(content)) !== null) {
      const componentName = match[1];
      const lineNumber = content.substring(0, match.index).split('\n').length;
      
      // Check if component has documentation
      const contextStart = Math.max(0, match.index - 200);
      const context = content.substring(contextStart, match.index);
      
      if (!context.includes('/**') && !context.includes('/*') && !context.includes('//')) {
        suggestions.push({
          id: this.generateSuggestionId(),
          type: 'component',
          target: componentName,
          suggestion: `Add JSDoc documentation for the ${componentName} component`,
          template: `/**
 * ${componentName} component
 * @param {Object} props - Component props
 * @returns {JSX.Element} Rendered component
 */`,
          priority: 3,
          createdAt: new Date()
        });
      }
    }

    // Generate security-focused documentation suggestions
    const securityFindings = findings.filter(f => f.type === 'security');
    for (const finding of securityFindings) {
      suggestions.push({
        id: this.generateSuggestionId(),
        type: 'security',
        target: finding.location.file,
        suggestion: `Add security documentation for ${finding.title}`,
        template: `/**
 * SECURITY NOTE: ${finding.title}
 * ${finding.description}
 * 
 * Mitigation: ${finding.recommendation}
 * CWE: ${finding.cweId}
 * OWASP: ${finding.owaspCategory}
 */`,
        priority: finding.severity === 'critical' ? 1 : 2,
        createdAt: new Date()
      });
    }

    return suggestions.sort((a, b) => a.priority - b.priority);
  }

  private calculateSummary(
    findings: VulnerabilityFinding[], 
    parsedFile: ParsedFile, 
    scanDuration: number
  ): ScanSummary {
    const summary = {
      totalFindings: findings.length,
      securityFindings: 0,
      performanceFindings: 0,
      criticalCount: 0,
      highCount: 0,
      mediumCount: 0,
      lowCount: 0,
      filesScanned: 1,
      linesOfCode: parsedFile.metadata.lines,
      scanDuration
    };

    for (const finding of findings) {
      if (finding.type === 'security') {
        summary.securityFindings++;
      } else {
        summary.performanceFindings++;
      }

      switch (finding.severity) {
        case 'critical':
          summary.criticalCount++;
          break;
        case 'high':
          summary.highCount++;
          break;
        case 'medium':
          summary.mediumCount++;
          break;
        case 'low':
          summary.lowCount++;
          break;
      }
    }

    return summary;
  }

  private calculateMetadata(parsedFile: ParsedFile): ScanMetadata {
    return {
      files: [parsedFile.path],
      languages: [parsedFile.language],
      frameworks: parsedFile.metadata.frameworks,
      dependencies: parsedFile.metadata.dependencies,
      totalSize: parsedFile.metadata.size
    };
  }

  private generateScanId(): string {
    const timestamp = Date.now();
    const hash = require('crypto').createHash('md5').update(`scan-${timestamp}`).digest('hex');
    return `scan-${hash.substring(0, 8)}`;
  }

  private generateRequestId(): string {
    const timestamp = Date.now();
    const hash = require('crypto').createHash('md5').update(`request-${timestamp}`).digest('hex');
    return `req-${hash.substring(0, 8)}`;
  }

  private generateSuggestionId(): string {
    const timestamp = Date.now();
    const hash = require('crypto').createHash('md5').update(`suggestion-${timestamp}`).digest('hex');
    return `sug-${hash.substring(0, 8)}`;
  }

  // Public methods for configuration
  enableRule(ruleId: string): void {
    this.analyzer.enableRule(ruleId);
  }

  disableRule(ruleId: string): void {
    this.analyzer.disableRule(ruleId);
  }

  getEnabledRules(): string[] {
    return this.analyzer.getEnabledRules().map(rule => rule.id);
  }

  getSupportedLanguages(): string[] {
    return this.parser.getSupportedLanguages();
  }

  isLanguageSupported(language: string): boolean {
    return this.parser.getSupportedLanguages().includes(language);
  }
} 